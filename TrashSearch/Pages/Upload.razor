@page "/upload"
@using TrashSearch.Services
@using TrashSearch.Components
@using TrashSearch.Data
@using System.Threading;
@using System.Threading.Tasks;
@inject AudioDownloaderService	DownloaderService
@inject FileTranscriberService	TransScriberService
@inject IndexerService			IndexerService;
@inject DatabaseService			DatabaseService;

<div style="color: white;">
	<h3>Upload new episodes to the database</h3>
	<div>
		@foreach (var k in _inputs.Keys)
		{
			<div style="display: flex; align-items: center; margin: 0 10px">
				<label> ep </label>
				<input style="width: 5rem" type="number" @bind="@_inputs[k].V1" />
				<input placeholder="url" type="text" style="width: 30rem" @bind="@_inputs[k].V2">
				<button @onclick="@(() => _inputs.Remove(k))">Remove</button>
			</div>
			
		}
		<button @onclick="@(() => { 
			int key = random.Next(); 
			_inputs.Add(key, new Pair<int, string>(
				(_inputs.Any()) ? _inputs.Last().Value.V1+1 : 1, "")
			);
		}
		)">Add video</button>
		<button @onclick="@(() => UploadAll(_inputs.Values.Select(v => v).ToList()))">Upload all</button>
	</div>
	<div style="color: var(--text)">
		<table>
			<tr>
				<th>Episode number</th>
				<th>Status</th>
				<th>Progress</th>
				<th>ETL</th>
			</tr>
			@foreach (var job in IndexerService.Jobs)
			{
				<tr>
					<th>@job.Id</th>
					<th>@job?.State.ToString()</th>
					<th><progress max="100" value="@((int)(job?.Progress*100.0??0))"></progress></th>
					@if (job?.State==IndexerService.IndexerJob.IndexingState.Indexing) {
						<th>@job.EstimatedTimeLeft()</th>
					}
					else
					{
						<th>--</th>
					}
				</tr>
			}
		</table>
		<h3>SYNLIG?</h3>
	</div>
	<div style="color: var(--text)">
		<h3>Indexed episodes</h3>
		<table>
			<tr>
				<th>Episode number</th>
				<th>Quotes</th>
				<th>Remove?</th>
			</tr>
			@foreach (var episode in _episodes)
			{
				<tr>
					<th>@episode.QuoteOrigin!.EpisodeNumber</th>
					<th>@episode.QuoteIds!.Count</th>
					<th>
						<button @onclick="@(() => DatabaseService.RemoveEpisode(mainCollectionName, metadataCollectionName, episode))">Remove</button>
					</th>
				</tr>
			}
		</table>
	</div>
</div>
@code {

	private class Pair<T1, T2>
	{
		public T1 V1 { get; set; }
		public T2 V2 { get; set; }
		public Pair(T1 v1, T2 v2)
		{
			V1 = v1;
			V2 = v2;
		}
		public Tuple<T1, T2> ToTuple()
		{
			return new(V1, V2);
		}
	}

	string mainCollectionName => "TrashTaste_4";
	string metadataCollectionName => "TrashTasteMetaData_4";

	private readonly Random random = new();

	//Not optimal, order is not well defined
	private Dictionary<int, Pair<int, string>> _inputs = new();

	private List<EpisodeCollection> _episodes = new();

	private System.Threading.Timer? timer;

	private bool _isSearching = false;

	protected override void OnInitialized()
	{
		//Create a timer that updates the progress once every second
		timer = new System.Threading.Timer(
			callback: (state) =>
			{
				InvokeAsync(StateHasChanged);
			},
			state: null,
			dueTime: TimeSpan.Zero,
			period: TimeSpan.FromSeconds(1)
		);

	}

	protected override async Task OnInitializedAsync()
	{
		var episode = await Task.Run(() => DatabaseService.GetEpisodeMetadata(metadataCollectionName, 1));
		Console.WriteLine($"Episode: {episode!.Serialize()}");
		if (!_isSearching){ 
			_isSearching = true;
			await Test();
		}
	}

	private async Task<int> Test()
	{
		
		//LÄR DIG VADFAN ASYNC GÖR!!!
		for (int i = 1; i < 100; i++)
		{
			

			var episode = await Task.Run(() => DatabaseService.GetEpisodeMetadata(metadataCollectionName, i));
			if (episode == null)
				continue;
			Console.WriteLine($"Added episode {i}");
			_episodes.Add(episode);
			await InvokeAsync(StateHasChanged);
		}
		await InvokeAsync(StateHasChanged);
		return 0;
	}

	private async Task UploadAll(List<Pair<int, string>> episodes, int maxThreads = 1)
	{
		if (!IndexerService.TryLockIndexer())
		{
			Console.WriteLine("An indexing job is already in action...");
			return;
		}

		// Indexing is now locked and can be started
		await IndexerService.IndexVideos(episodes.Select(p => p.ToTuple()));
	}

	private async Task UpdateIndexingJobs()
	{
		await InvokeAsync(StateHasChanged);
	}

	/*
	private async Task UploadAll(List<Pair<int, string>> episodes, int maxThreads = 4)
	{
		List<int> k = new();
		k.BinarySearch(1);
		Console.WriteLine("Uploading all...");

		// create a SemaphoreSlim object with a count of 4
		SemaphoreSlim semaphore = new SemaphoreSlim(maxThreads);

		// execute your function in parallel with a maximum of 4 threads
		await Task.WhenAll(episodes.Select(async input =>
		{
			await semaphore.WaitAsync();
			try
			{
				await UploadVideo(input.V2, input.V1);
			}
			finally
			{
				semaphore.Release();
			}
		}));
	}*/

}