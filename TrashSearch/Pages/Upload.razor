@page "/upload"
@using TrashSearch.Services
@using TrashSearch.Components
@using TrashSearch.Data
@using System.Threading;
@using System.Threading.Tasks;
@inject AudioDownloaderService	DownloaderService
@inject FileTranscriberService	TransScriberService
@inject IndexerService			IndexerService;

<div style="color: white;">
	<h3>Upload new episodes to the database</h3>
	<div>
		@foreach (var k in _inputs.Keys)
		{
			<div style="display: flex; align-items: center; margin: 0 10px">
				<label> ep </label>
				<input style="width: 5rem" type="number" @bind="@_inputs[k].V1" />
				<input placeholder="url" type="text" style="width: 30rem" @bind="@_inputs[k].V2">
				<button @onclick="@(() => _inputs.Remove(k))">Remove</button>
			</div>
			
		}
		<button @onclick="@(() => { 
			int key = random.Next(); 
			_inputs.Add(key, new Pair<int, string>(
				(_inputs.Any()) ? _inputs.Last().Value.V1+1 : 1, "")
			);
		}
		)">Add video</button>
		<button @onclick="@(() => UploadAll(_inputs.Values.Select(v => v).ToList()))">Upload all</button>
	</div>
	<div style="color: var(--text)">
		<table>
			<tr>
				<th>Episode number</th>
				<th>Status</th>
				<th>Progress</th>
				<th>ETL</th>
			</tr>
			@foreach (var job in IndexerService.Jobs)
			{
				<tr>
					<th>@job.Id</th>
					<th>@job?.State.ToString()</th>
					<th><progress max="100" value="@((int)(job?.Progress*100.0??0))"></progress></th>
					@if (job?.State==IndexerService.IndexerJob.IndexingState.Indexing) {
						<th>@job.EstimatedTimeLeft()</th>
					}
					else
					{
						<th>--</th>
					}
				</tr>
			}
		</table>
	</div>
</div>
@code {

	private class Pair<T1, T2>
	{
		public T1 V1 { get; set; }
		public T2 V2 { get; set; }
		public Pair(T1 v1, T2 v2)
		{
			V1 = v1;
			V2 = v2;
		}
		public Tuple<T1, T2> ToTuple()
		{
			return new(V1, V2);
		}
	}

	string mainCollectionName => "Test10";
	string metadataCollectionName => "Test10_Meta";

	private readonly Random random = new();

	//Not optimal, order is not well defined
	private Dictionary<int, Pair<int, string>> _inputs = new();

	private DatabaseService _database = new ();

	private System.Threading.Timer? timer;

	protected override void OnInitialized()
	{
		//Create a timer that updates the progress once every second
		timer = new System.Threading.Timer(
			callback: (state) =>
			{
				InvokeAsync(StateHasChanged);
			},
			state: null,
			dueTime: TimeSpan.Zero,
			period: TimeSpan.FromSeconds(1)
		);

		//PRINT ALL POINTS IN THE CURRENT COLLECITON:
		var pointWaiter = _database.GetAllPointsInCollection(mainCollectionName, 1);
		pointWaiter.Wait();
		var points = pointWaiter.Result;
		points.ForEach(p => Console.WriteLine($"\t {p.Metadata.Id}: {p.Metadata.Text}"));
	}

	private async Task UploadAll(List<Pair<int, string>> episodes, int maxThreads = 1)
	{
		if (!IndexerService.TryLockIndexer())
		{
			Console.WriteLine("An indexing job is already in action...");
			return;
		}

		// Indexing is now locked and can be started
		await IndexerService.IndexVideos(episodes.Select(p => p.ToTuple()));
	}

	private async Task UpdateIndexingJobs()
	{
		await InvokeAsync(StateHasChanged);
	}

	/*
	private async Task UploadAll(List<Pair<int, string>> episodes, int maxThreads = 4)
	{
		List<int> k = new();
		k.BinarySearch(1);
		Console.WriteLine("Uploading all...");

		// create a SemaphoreSlim object with a count of 4
		SemaphoreSlim semaphore = new SemaphoreSlim(maxThreads);

		// execute your function in parallel with a maximum of 4 threads
		await Task.WhenAll(episodes.Select(async input =>
		{
			await semaphore.WaitAsync();
			try
			{
				await UploadVideo(input.V2, input.V1);
			}
			finally
			{
				semaphore.Release();
			}
		}));
	}*/

}